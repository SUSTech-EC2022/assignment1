%*****IEEE CEC 2022 Competition on Dynamic Optimization Problems Generated by Generalized Moving Peaks Benchmark******
%Author: Danial Yazdani
%Last Edited: December 06, 2021
%
% ------------
% Reference:
% ------------
%  
%  D. Yazdani et al.,
%            "Benchmarking Continuous Dynamic Optimization: Survey and Generalized Test Suite,"
%            IEEE Transactions on Cybernetics (2020).
% 
%  D. Yazdani et al.,
%            "Generalized Moving Peaks Benchmark," arXiv:2106.06174, (2021).
% 
%  T. Blackwell and J. Branke,
%            "Multiswarms, exclusion, and anti-convergence in dynamic environments"
%            IEEE Transactions on Evolutionary Computation (2006).
% ------------
% Notification:
% ------------
% This code solves Generalized Moving Peaks Benchmark (GMPB) by mQSO.
% It is assumed that the environmental changes are VISIBLE, therefore,
% mQSO is informed about changes (i.e., mQSO does not need to detect
% environmental changes). Also note that mQSO does not access to a prior knowledge
% about the shift severity value. The shift severity is learned in this code.
%
% 
% -------
% Inputs:
% -------
%
%    The Participants can set peak number, change frequency, dimension, 
%    and shift severity in lines 59-62 of "main.m" according to the
%    competition instractions available in the following link:
%                                
%                 https://www.danialyazdani.com/CEC-2022
% 
%
% ------------
% Output:
% ------------
% 
% Offline error
% 
% --------
% License:
% --------
% This program is to be used under the terms of the GNU General Public License
% (http://www.gnu.org/copyleft/gpl.html).
% Author: Danial Yazdani
% e-mail: danial.yazdani AT gmail dot com
%         danial.yazdani AT yahoo dot com
% Copyright notice: (c) 2021 Danial Yazdani
%*********************************************************************************************************************
clear all;close all;clc;
%% Input variables
%********Benchmark parameters and Run number***
PeakNumbers = [5,	10,	25,	50,	100,	10,	10,	10,	10,	10,	10,	10,  1,  10];
ChangeFrequencys = [5000,	5000,	5000,	5000,	5000,	2500,	1000,	500,	5000,	5000,	5000,	5000,  5000,  5000];
Dimensions = [5,	5,	5,	5,	5,	5,	5,	5,	10,	20,	5,	5,  5,  2];
ShiftSeveritys = [1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	2,	5,   1,  1];
%%
for problemNum = 1:14

    PeakNumber                               = PeakNumbers(problemNum);  %The default value is 10
    ChangeFrequency                          = ChangeFrequencys(problemNum);%The default value is 5000
    Dimension                                = Dimensions(problemNum);   %The default value is 5
    ShiftSeverity                            = ShiftSeveritys(problemNum);   %The default value is 1
    EnvironmentNumber                        = 100; %The default value is 100
    RunNumber                                = 31;  %It should be set to 31
    
    f = fopen(sprintf('F%d.dat', problemNum), 'w');
    OfflineError = NaN(1,RunNumber);
    for RunCounter=1 : RunNumber
        rng(RunCounter);%This random seed setting is used to initialize the Problem-This must be identical for all peer algorithms to have a fair comparison.
        Problem = BenchmarkGenerator(PeakNumber,ChangeFrequency,Dimension,ShiftSeverity,EnvironmentNumber);
        rng('shuffle');%Set a random seed for the optimizer based on the system clock
        %% Initialiing Optimizer
        clear Optimizer;
        Results = NaN(2,Problem.EnvironmentNumber);
        Optimizer.Dimension = Problem.Dimension;
        Optimizer.PopulationSize = 5;
        Optimizer.MaxCoordinate   = Problem.MaxCoordinate;
        Optimizer.MinCoordinate = Problem.MinCoordinate;
        Optimizer.DiversityPlus = 1;
        Optimizer.x = 0.729843788;
        Optimizer.c1 = 2.05;
        Optimizer.c2 = 2.05;
        Optimizer.ShiftSeverity = 1;%initial shift severity
        Optimizer.QuantumRadius = Optimizer.ShiftSeverity;
        Optimizer.QuantumNumber = 5;
        Optimizer.SwarmNumber = 10;
        Optimizer.ExclusionLimit = 0.5 * ((Optimizer.MaxCoordinate-Optimizer.MinCoordinate) / ((Optimizer.SwarmNumber) ^ (1 / Optimizer.Dimension)));
        Optimizer.ConvergenceLimit = Optimizer.ExclusionLimit;
        for ii=1 : Optimizer.SwarmNumber
            [Optimizer.pop(ii),Problem] = InitializingOptimizer(Optimizer.Dimension,Optimizer.MinCoordinate,Optimizer.MaxCoordinate,Optimizer.PopulationSize,Problem);
        end
        %% main loop
        while 1
            [Optimizer,Problem] = Optimization(Optimizer,Problem);
            if Problem.RecentChange == 1%When an environmental change has happened
                Problem.RecentChange = 0;
                [Optimizer,Problem] = Reaction(Optimizer,Problem);
                VisualizationFlag = 0;
                clc; disp(['Run number: ',num2str(RunCounter),'   Environment number: ',num2str(Problem.Environmentcounter)]);
            end
            if  Problem.FE >= Problem.MaxEvals%When termination criteria has been met
                break;
            end
        end
        OfflineError(1,RunCounter) = mean(Problem.CurrentError);
    end
    E_o = [mean(OfflineError),median(OfflineError),std(OfflineError)/sqrt(RunNumber)];
    close;clc;
    disp(['Offline error ==> ', ' Mean = ', num2str(E_o(1)), ', Median = ', num2str(E_o(2)), ', Standard Error = ', num2str(E_o(3))]);
    fprintf(f, '%.f ', OfflineError);
    fclose(f);
end